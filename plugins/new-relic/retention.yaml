documentationURL: "https://docs.newrelic.com/"
configurations:
  api-key: "New Relic license key, must be an 'INGEST - LICENSE' key (see https://one.newrelic.com/api-keys)"
defaultExportURL: "otlp.nr-data.net:443"
allowCustomExportURL: true
presetScripts:
  - name: "HTTP Metrics"
    description: "This script sends HTTP metrics to New Relic's OTel endpoint."
    script: |
      #px:set max_output_rows_per_table=10000

      import px

      df = px.DataFrame(table='http_events', start_time=px.plugin.start_time, end_time=px.plugin.end_time)

      ns_prefix = df.ctx['namespace'] + '/'
      df.container = df.ctx['container_name']
      df.pod = px.strip_prefix(ns_prefix, df.ctx['pod'])
      df.service = px.strip_prefix(ns_prefix, df.ctx['service'])
      df.namespace = df.ctx['namespace']

      df.status_code = df.resp_status

      df = df.groupby(['status_code', 'pod', 'container','service', 'namespace']).agg(
          latency_min=('latency', px.min),
          latency_max=('latency', px.max),
          latency_sum=('latency', px.sum),
          latency_count=('latency', px.count),
          time_=('time_', px.max),
      )

      df.latency_min = df.latency_min / 1000000
      df.latency_max = df.latency_max / 1000000
      df.latency_sum = df.latency_sum / 1000000

      df.cluster_name = px.vizier_name()
      df.cluster_id = px.vizier_id()
      df.pixie = 'pixie'

      px.export(
        df, px.otel.Data(
          resource={
            'service.name': df.service,
            'k8s.container.name': df.container,
            'service.instance.id': df.pod,
            'k8s.pod.name': df.pod,
            'k8s.namespace.name': df.namespace,
            'px.cluster.id': df.cluster_id,
            'k8s.cluster.name': df.cluster_name,
            'instrumentation.provider': df.pixie,
          },
          data=[
            px.otel.metric.Summary(
              name='http.server.duration',
              description='measures the duration of the inbound HTTP request',
              unit='ms',
              count=df.latency_count,
              sum=df.latency_sum,
              quantile_values={
                0.0: df.latency_min,
                1.0: df.latency_max,
              },
              attributes={
                'http.status_code': df.status_code,
              },
          )],
        ),
      )
    defaultFrequencyS: 10
  - name: "HTTP Spans"
    description: "This script sends HTTP span events (distributed tracing) to New Relic's OTel endpoint."
    script: |
      #px:set max_output_rows_per_table=1500

      import px

      df = px.DataFrame('http_events', start_time=px.plugin.start_time, end_time=px.plugin.end_time)

      ns_prefix = df.ctx['namespace'] + '/'
      df.container = df.ctx['container_name']
      df.pod = px.strip_prefix(ns_prefix, df.ctx['pod'])
      df.service = px.strip_prefix(ns_prefix, df.ctx['service'])
      df.namespace = df.ctx['namespace']

      df = df.head(15000)
      df.req_start_time = df.time_ - df.latency
      df.parent_pod_id = px.ip_to_pod_id(df.remote_addr)
      df.parent_service = px.replace('.*/', px.pod_id_to_service_name(df.parent_pod_id), '')
      df.parent_pod = px.replace('.*/', px.pod_id_to_pod_name(df.parent_pod_id), '')
      df.host = px.pluck(df.req_headers, 'Host')
      df.req_url = df.host + df.req_path

      df.user_agent = px.pluck(df.req_headers, 'User-Agent')
      df.trace_id = px.pluck(df.req_headers, 'X-B3-TraceId')
      df.span_id = px.pluck(df.req_headers, 'X-B3-SpanId')
      df.parent_span_id = px.pluck(df.req_headers, 'X-B3-ParentSpanId')

      # Strip out all but the actual path value from req_path
      df.req_path = px.uri_recompose('', '', '', 0, px.pluck(px.uri_parse(df.req_path), 'path'), '', '')

      # Replace any Hex IDS from the path with <id>
      df.req_path = px.replace('/[a-fA-F0-9\-:]{6,}(/?)', df.req_path, '/<id>\\1')

      df.cluster_name = px.vizier_name()
      df.cluster_id = px.vizier_id()
      df.pixie = 'pixie'

      px.export(
        df, px.otel.Data(
          resource={
            'service.name': df.service,
            'k8s.container.name': df.container,
            'service.instance.id': df.pod,
            'k8s.pod.name': df.pod,
            'k8s.namespace.name': df.namespace,
            'px.cluster.id': df.cluster_id,
            'k8s.cluster.name': df.cluster_name,
            'instrumentation.provider': df.pixie,
          },
          data=[
            px.otel.trace.Span(
              name=df.req_path,
              start_time=df.req_start_time,
              end_time=df.time_,
              trace_id=df.trace_id,
              span_id=df.span_id,
              parent_span_id=df.parent_span_id,
              kind=px.otel.trace.SPAN_KIND_SERVER,
              attributes={
                # NOTE: the integration handles splitting of services.
                'parent.service.name': df.parent_service,
                'parent.k8s.pod.name': df.parent_pod,
                'http.method': df.req_method,
                'http.url': df.req_url,
                'http.target': df.req_path,
                'http.host': df.host,
                'http.status_code': df.resp_status,
                'http.user_agent': df.user_agent,
              },
            ),
          ],
        ),
      )
    defaultFrequencyS: 10
  - name: "JVM Metrics"
    description: "This script sends JVM metrics to New Relic's OTel endpoint."
    script: |
      #px:set max_output_rows_per_table=10000

      import px

      df = px.DataFrame('jvm_stats', start_time=px.plugin.start_time, end_time=px.plugin.end_time)

      ns_prefix = df.ctx['namespace'] + '/'
      df.container = df.ctx['container_name']
      df.pod = px.strip_prefix(ns_prefix, df.ctx['pod'])
      df.service = px.strip_prefix(ns_prefix, df.ctx['service'])
      df.namespace = df.ctx['namespace']

      df.used_heap_size = px.Bytes(df.used_heap_size)
      df.total_heap_size = px.Bytes(df.total_heap_size)
      df.max_heap_size = px.Bytes(df.max_heap_size)

      # Aggregate over each process, k8s_object.
      df = df.groupby(['upid','container', 'pod', 'service', 'namespace']).agg(
          young_gc_time_max=('young_gc_time', px.max),
          young_gc_time_min=('young_gc_time', px.min),
          full_gc_time_max=('full_gc_time', px.max),
          full_gc_time_min=('full_gc_time', px.min),
          used_heap_size=('used_heap_size', px.mean),
          total_heap_size=('total_heap_size', px.mean),
          max_heap_size=('max_heap_size', px.mean),
          time_=('time_', px.max),
      )

      # Convert the counter metrics into accumulated values over the window.
      df.young_gc_time = df.young_gc_time_max - df.young_gc_time_min
      df.full_gc_time = df.full_gc_time_max - df.full_gc_time_min

      # Aggregate over each k8s_object.
      df = df.groupby(['container', 'pod', 'service', 'namespace']).agg(
          young_gc_time=('young_gc_time', px.sum),
          full_gc_time=('full_gc_time', px.sum),
          used_heap_size=('used_heap_size', px.sum),
          max_heap_size=('max_heap_size', px.sum),
          total_heap_size=('total_heap_size', px.sum),
          time_=('time_', px.max),
      )
      df.young_gc_time = px.DurationNanos(df.young_gc_time) / 1000000.0
      df.full_gc_time = px.DurationNanos(df.full_gc_time) / 1000000.0

      df.cluster_name = px.vizier_name()
      df.cluster_id = px.vizier_id()
      df.pixie = 'pixie'

      df.young = 'young'
      df.full = 'full'
      df.used = 'used'
      df.total = 'total'
      df.heap = 'area'
      df.max = 'max'

      px.export(
        df, px.otel.Data(
          resource={
            'service.name': df.service,
            'k8s.container.name': df.container,
            'service.instance.id': df.pod,
            'k8s.pod.name': df.pod,
            'k8s.namespace.name': df.namespace,
            'px.cluster.id': df.cluster_id,
            'k8s.cluster.name': df.cluster_name,
            'instrumentation.provider': df.pixie,
          },
          data=[
            px.otel.metric.Gauge(
              name='runtime.jvm.gc.collection',
              description='',
              unit='ms',
              value=df.young_gc_time,
              attributes={'gc': df.young},
            ),
            px.otel.metric.Gauge(
              name='runtime.jvm.gc.collection',
              description=''
              unit='ms',
              value=df.full_gc_time,
              attributes={'gc': df.full},
            ),
            px.otel.metric.Gauge(
              name='runtime.memory.area',
              description=''
              unit='bytes',
              value=df.used_heap_size,
              attributes={'type': df.used, 'area': df.heap},
            ),
            px.otel.metric.Gauge(
              name='runtime.memory.area',
              description=''
              unit='bytes',
              value=df.total_heap_size,
              attributes={'type': df.total, 'area': df.heap},
            ),
            px.otel.metric.Gauge(
              name='runtime.memory.area',
              description=''
              unit='bytes',
              value=df.max_heap_size,
              attributes={'type': df.max, 'area': df.heap},
            ),
          ],
        ),
      )
    defaultFrequencyS: 10
  - name: "PostgreSQL Spans"
    description: "This script generates span events from queries to PostgreSQL databases and sends them to New Relic's OTel endpoint."
    script: |
      #px:set max_output_rows_per_table=500

      import px

      def remove_ns_prefix(column):
        return px.replace('[a-z0-9\-]*/', column, '')

      def add_source_dest_columns(df):
        df.pod = df.ctx['pod']
        df.namespace = df.ctx['namespace']

        # If remote_addr is a pod, get its name. If not, use IP address.
        df.ra_pod = px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr))
        df.is_ra_pod = df.ra_pod != ''
        df.ra_name = px.select(df.is_ra_pod, df.ra_pod, df.remote_addr)

        df.is_server_tracing = df.trace_role == 2
        df.is_source_pod_type = px.select(df.is_server_tracing, df.is_ra_pod, True)
        df.is_dest_pod_type = px.select(df.is_server_tracing, True, df.is_ra_pod)

        # Set client and server based on trace_role.
        df.source_pod = px.select(df.is_server_tracing, df.ra_name, df.pod)
        df.destination_pod = px.select(df.is_server_tracing, df.pod, df.ra_name)

        df = df.drop(['ra_pod', 'is_ra_pod', 'ra_name', 'is_server_tracing'])
        df.source_service = px.pod_name_to_service_name(df.source_pod)
        df.destination_service = px.pod_name_to_service_name(df.destination_pod)
        df.destination_namespace = px.pod_name_to_namespace(df.destination_pod)
        df.source_namespace = px.pod_name_to_namespace(df.source_pod)

        df.source_service = remove_ns_prefix(df.source_service)
        df.destination_service = remove_ns_prefix(df.destination_service)
        df.source_pod = remove_ns_prefix(df.source_pod)
        df.destination_pod = remove_ns_prefix(df.destination_pod)

        # If the destination service is missing then try the nslookup
        df.destination_service = px.select(
            df.destination_service != '',
            df.destination_service,
            px.nslookup(df.remote_addr),
        )
        # If the destination service is still missing then set the remote_addr
        df.destination_service = px.select(
            df.destination_service != '',
            df.destination_service,
            df.remote_addr,
        )
        return df

      df = px.DataFrame('pgsql_events', start_time=px.plugin.start_time, end_time=px.plugin.end_time)
      df = add_source_dest_columns(df)

      df.normed_query_struct = px.normalize_pgsql(df.req, df.req_cmd)
      df.query = px.pluck(df.normed_query_struct, 'query')
      df = df[df.query != ""]

      df.start_time = df.time_ - df.latency

      df.cluster_name = px.vizier_name()
      df.cluster_id = px.vizier_id()
      df.pixie = 'pixie'
      df.db_system = 'postgres'

      px.export(
        df, px.otel.Data(
          resource={
            'service.name': df.source_service,
            'service.instance.id': df.source_pod,
            'k8s.namespace.name': df.source_namespace,
            'postgres.service.name': df.destination_service,
            'postgres.pod.name': df.destination_pod,
            'postgres.namespace.name': df.destination_namespace,
            'k8s.cluster.name': df.cluster_name,
            'px.cluster.id': df.cluster_id,
            'instrumentation.provider': df.pixie,
          },
          data=[
            px.otel.trace.Span(
              name=df.query,
              start_time=df.start_time,
              end_time=df.time_,
              kind=px.otel.trace.SPAN_KIND_CLIENT,
              attributes={
                'db.system': df.db_system,
                'postgres.req_cmd': df.req_cmd,
                'postgres.req': df.req,
                # Disabling sending df.resp for now until illegal characters are handled.
                # 'postgres.resp': df.resp,
                'postgres.resp_latency': df.latency,
              },
            ),
          ],
        ),
      )
    defaultFrequencyS: 10
  - name: "PostgreSQL Metrics"
    description: "This script sends PostgreSQL metrics to New Relic's OTel endpoint."
    script: |
      #px:set max_output_rows_per_table=10000

      import px

      def remove_ns_prefix(column):
        return px.replace('[a-z0-9\-]*/', column, '')

      def add_source_dest_columns(df):
        df.pod = df.ctx['pod']
        df.namespace = df.ctx['namespace']

        # If remote_addr is a pod, get its name. If not, use IP address.
        df.ra_pod = px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr))
        df.is_ra_pod = df.ra_pod != ''
        df.ra_name = px.select(df.is_ra_pod, df.ra_pod, df.remote_addr)

        df.is_server_tracing = df.trace_role == 2
        df.is_source_pod_type = px.select(df.is_server_tracing, df.is_ra_pod, True)
        df.is_dest_pod_type = px.select(df.is_server_tracing, True, df.is_ra_pod)

        # Set client and server based on trace_role.
        df.source_pod = px.select(df.is_server_tracing, df.ra_name, df.pod)
        df.destination_pod = px.select(df.is_server_tracing, df.pod, df.ra_name)

        df = df.drop(['ra_pod', 'is_ra_pod', 'ra_name', 'is_server_tracing'])
        df.source_service = px.pod_name_to_service_name(df.source_pod)
        df.destination_service = px.pod_name_to_service_name(df.destination_pod)
        df.destination_namespace = px.pod_name_to_namespace(df.destination_pod)
        df.source_namespace = px.pod_name_to_namespace(df.source_pod)

        df.source_service = remove_ns_prefix(df.source_service)
        df.destination_service = remove_ns_prefix(df.destination_service)
        df.source_pod = remove_ns_prefix(df.source_pod)
        df.destination_pod = remove_ns_prefix(df.destination_pod)

        # If the destination service is missing then try the nslookup
        df.destination_service = px.select(
          df.destination_service != '',
          df.destination_service,
          px.nslookup(df.remote_addr),
        )
        # If the destination service is still missing then set the remote_addr
        df.destination_service = px.select(
          df.destination_service != '',
          df.destination_service,
          df.remote_addr,
        )
        return df

      df = px.DataFrame('pgsql_events', start_time=px.plugin.start_time, end_time=px.plugin.end_time)
      df = add_source_dest_columns(df)

      df.latency = df.latency / (1000 * 1000)
      df.req_bytes = px.length(df.req)
      df.resp_bytes = px.length(df.resp)
      df = df.groupby(['source_pod', 'source_service', 'source_namespace', 'destination_pod', 'destination_service',
                         'destination_namespace', 'req_cmd']).agg(
        latency_count=('latency', px.count),
        latency_min=('latency', px.min),
        latency_max=('latency', px.max),
        latency_sum=('latency', px.sum),
        time_=('time_', px.max),
        req_bytes=('req_bytes', px.sum),
        resp_bytes=('resp_bytes', px.sum),
      )

      df.cluster_name = px.vizier_name()
      df.cluster_id = px.vizier_id()
      df.pixie = 'pixie'
      df.db_system = 'postgres'

      px.export(
        df, px.otel.Data(
          resource={
            'service.name': df.source_service,
            'service.instance.id': df.source_pod,
            'k8s.namespace.name': df.source_namespace,
            'postgres.service.name': df.destination_service,
            'postgres.pod.name': df.destination_pod,
            'postgres.namespace.name': df.destination_namespace,
            'postgres.req_cmd': df.req_cmd,
            'k8s.cluster.name': df.cluster_name,
            'px.cluster.id': df.cluster_id,
            'instrumentation.provider': df.pixie,
            'db.system': df.db_system,
          },
          data=[
            px.otel.metric.Summary(
              name='postgres.latency',
              count=df.latency_count,
              sum=df.latency_sum,
              unit='ms',
              quantile_values={
                0.0: df.latency_min,
                1.0: df.latency_max,
              },
            ),
            px.otel.metric.Gauge(
              name='postgres.req_bytes',
              description='',
              value=df.req_bytes,
            ),
            px.otel.metric.Gauge(
              name='postgres.resp_bytes',
              description='',
              value=df.resp_bytes,
            )
          ]
        ),
      )
    defaultFrequencyS: 10
  - name: "MySQL Spans"
    description: "This script generates span events from queries to MySQL databases and sends them to New Relic's OTel endpoint."
    script: |
      #px:set max_output_rows_per_table=500

      import px

      def remove_duplicate_traces(df):
          ''' Removes duplicate traces.

              For historical reasons, Pixie traces MySQL requests on both the client AND server side:
              https://github.com/pixie-io/pixie/blob/5e5598ac46f39219148a36468b5318b1466a92d4/src/stirling/source_connectors/socket_tracer/conn_tracker.cc#L639
          '''

          # Keep client-side traces if server is outside the cluster (can't be resolved to pod or svc)
          df.remote_pod_id = px.ip_to_pod_id(df.remote_addr)
          df.remote_service_id = px.ip_to_service_id(df.remote_addr)
          df.remote_outside_cluster = df.remote_pod_id == '' and df.remote_service_id == ''
          df_client_traces = df[df.trace_role == 1 and df.remote_outside_cluster]

          df_server_traces = df[df.trace_role == 2]
          df_server_traces.append(df_client_traces)
          return df_server_traces

      def remove_ns_prefix(column):
          return px.replace('[a-z0-9\-]*/', column, '')

      def add_source_dest_columns(df):
          df.pod = df.ctx['pod']
          df.namespace = df.ctx['namespace']

          # If remote_addr is a pod, get its name. If not, use IP address.
          df.ra_pod = px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr))
          df.is_ra_pod = df.ra_pod != ''
          df.ra_name = px.select(df.is_ra_pod, df.ra_pod, df.remote_addr)

          df.is_server_tracing = df.trace_role == 2
          df.is_source_pod_type = px.select(df.is_server_tracing, df.is_ra_pod, True)
          df.is_dest_pod_type = px.select(df.is_server_tracing, True, df.is_ra_pod)

          # Set client and server based on trace_role.
          df.source_pod = px.select(df.is_server_tracing, df.ra_name, df.pod)
          df.destination_pod = px.select(df.is_server_tracing, df.pod, df.ra_name)

          df = df.drop(['ra_pod', 'is_ra_pod', 'ra_name', 'is_server_tracing'])
          df.source_service = px.pod_name_to_service_name(df.source_pod)
          df.destination_service = px.pod_name_to_service_name(df.destination_pod)
          df.destination_namespace = px.pod_name_to_namespace(df.destination_pod)
          df.source_namespace = px.pod_name_to_namespace(df.source_pod)

          df.source_service = remove_ns_prefix(df.source_service)
          df.destination_service = remove_ns_prefix(df.destination_service)
          df.source_pod = remove_ns_prefix(df.source_pod)
          df.destination_pod = remove_ns_prefix(df.destination_pod)

          # If the destination service is missing then try the nslookup
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              px.nslookup(df.remote_addr),
          )
          # If the destination service is still missing then set the remote_addr
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              df.remote_addr,
          )
          return df

      df = px.DataFrame('mysql_events', start_time=px.plugin.start_time, end_time=px.plugin.end_time)
      df = remove_duplicate_traces(df)
      df = add_source_dest_columns(df)

      df.normed_query_struct = px.normalize_mysql(df.req_body, df.req_cmd)
      df.query = px.pluck(df.normed_query_struct, 'query')
      df = df[df.query != ""]

      df.start_time = df.time_ - df.latency
      df.latency = df.latency / (1000 * 1000)
      df.req_bytes = px.length(df.req_body)
      df.resp_bytes = px.length(df.resp_body)

      df.cluster_name = px.vizier_name()
      df.cluster_id = px.vizier_id()
      df.pixie = 'pixie'
      df.db_system = 'mysql'

      px.export(
        df, px.otel.Data(
          resource={
            'service.name': df.source_service,
            'service.instance.id': df.source_pod,
            'k8s.namespace.name': df.source_namespace,
            'mysql.service.name': df.destination_service,
            'mysql.pod.name': df.destination_pod,
            'mysql.namespace.name': df.destination_namespace,
            'k8s.cluster.name': df.cluster_name,
            'px.cluster.id': df.cluster_id,
            'instrumentation.provider': df.pixie,
          },
          data=[
            px.otel.trace.Span(
              name=df.query,
              start_time=df.start_time,
              end_time=df.time_,
              kind=px.otel.trace.SPAN_KIND_CLIENT,
              attributes={
                'mysql.req_cmd': df.req_cmd,
                'mysql.req_body': df.req_body,
                'mysql.req_bytes': df.req_bytes,
                'mysql.resp_bytes': df.resp_bytes,
                'mysql.resp_latency': df.latency,
                'mysql.resp_status': df.resp_status,
                'mysql.resp_body': df.resp_body,
                'db.system': df.db_system,
              },
            ),
          ],
        ),
      )
    defaultFrequencyS: 10
  - name: "MySQL Metrics"
    description: "This script sends MySQL metrics to New Relic's OTel endpoint."
    script: |
      #px:set max_output_rows_per_table=10000

      import px

      def remove_duplicate_traces(df):
          ''' Removes duplicate traces.

              For historical reasons, Pixie traces MySQL requests on both the client AND server side:
              https://github.com/pixie-io/pixie/blob/5e5598ac46f39219148a36468b5318b1466a92d4/src/stirling/source_connectors/socket_tracer/conn_tracker.cc#L639
          '''

          # Keep client-side traces if server is outside the cluster (can't be resolved to pod or svc)
          df.remote_pod_id = px.ip_to_pod_id(df.remote_addr)
          df.remote_service_id = px.ip_to_service_id(df.remote_addr)
          df.remote_outside_cluster = df.remote_pod_id == '' and df.remote_service_id == ''
          df_client_traces = df[df.trace_role == 1 and df.remote_outside_cluster]

          df_server_traces = df[df.trace_role == 2]
          df_server_traces.append(df_client_traces)
          return df_server_traces

      def remove_ns_prefix(column):
          return px.replace('[a-z0-9\-]*/', column, '')

      def add_source_dest_columns(df):
          df.pod = df.ctx['pod']
          df.namespace = df.ctx['namespace']

          # If remote_addr is a pod, get its name. If not, use IP address.
          df.ra_pod = px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr))
          df.is_ra_pod = df.ra_pod != ''
          df.ra_name = px.select(df.is_ra_pod, df.ra_pod, df.remote_addr)

          df.is_server_tracing = df.trace_role == 2
          df.is_source_pod_type = px.select(df.is_server_tracing, df.is_ra_pod, True)
          df.is_dest_pod_type = px.select(df.is_server_tracing, True, df.is_ra_pod)

          # Set client and server based on trace_role.
          df.source_pod = px.select(df.is_server_tracing, df.ra_name, df.pod)
          df.destination_pod = px.select(df.is_server_tracing, df.pod, df.ra_name)

          df = df.drop(['ra_pod', 'is_ra_pod', 'ra_name', 'is_server_tracing'])
          df.source_service = px.pod_name_to_service_name(df.source_pod)
          df.destination_service = px.pod_name_to_service_name(df.destination_pod)
          df.destination_namespace = px.pod_name_to_namespace(df.destination_pod)
          df.source_namespace = px.pod_name_to_namespace(df.source_pod)

          df.source_service = remove_ns_prefix(df.source_service)
          df.destination_service = remove_ns_prefix(df.destination_service)
          df.source_pod = remove_ns_prefix(df.source_pod)
          df.destination_pod = remove_ns_prefix(df.destination_pod)

          # If the destination service is missing then try the nslookup
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              px.nslookup(df.remote_addr),
          )
          # If the destination service is still missing then set the remote_addr
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              df.remote_addr,
          )
          return df

      df = px.DataFrame('mysql_events', start_time=px.plugin.start_time, end_time=px.plugin.end_time)
      df = remove_duplicate_traces(df)
      df = add_source_dest_columns(df)

      df.latency = df.latency / (1000 * 1000)
      df.req_bytes = px.length(df.req_body)
      df.resp_bytes = px.length(df.resp_body)
      df = df.groupby(['source_pod', 'source_service', 'source_namespace', 'destination_pod', 'destination_service',
                        'destination_namespace', 'req_cmd', 'resp_status']).agg(
          latency_count=('latency', px.count),
          latency_min=('latency', px.min),
          latency_max=('latency', px.max),
          latency_sum=('latency', px.sum),
          time_=('time_', px.max),
          req_bytes=('req_bytes', px.sum),
          resp_bytes=('resp_bytes', px.sum),
      )

      df.req_cmd = px.mysql_command_name(df.req_cmd)
      df.cluster_name = px.vizier_name()
      df.cluster_id = px.vizier_id()
      df.pixie = 'pixie'
      df.db_system = 'mysql'

      px.export(
        df, px.otel.Data(
          resource={
            'service.name': df.source_service,
            'service.instance.id': df.source_pod,
            'k8s.namespace.name': df.source_namespace,
            'mysql.service.name': df.destination_service,
            'mysql.pod.name': df.destination_pod,
            'mysql.namespace.name': df.destination_namespace,
            'mysql.req_cmd': df.req_cmd,
            'mysql.resp_status': df.resp_status,
            'k8s.cluster.name': df.cluster_name,
            'px.cluster.id': df.cluster_id,
            'instrumentation.provider': df.pixie,
            'db.system': df.db_system,
          },
          data=[
            px.otel.metric.Summary(
                name='mysql.latency',
                count=df.latency_count,
                sum=df.latency_sum,
                unit='ms',
                quantile_values={
                  0.0: df.latency_min,
                  1.0: df.latency_max,
                },
            ),
            px.otel.metric.Gauge(
              name='mysql.req_bytes',
              description='',
              value=df.req_bytes,
            ),
            px.otel.metric.Gauge(
              name='mysql.resp_bytes',
              description='',
              value=df.resp_bytes,
            )
        ]
        ),
      )
    defaultFrequencyS: 10
  - name: "Kafka Metrics"
    description: "This script generates metrics from Kafka and sends them to New Relic's OTel endpoint."
    defaultDisabled: true
    defaultFrequencyS: 10
    script: |
      import px

      def unnest_topics_and_partitions(df, body_field: str):
          '''
          Unnest the topics and partitions from a data frame. body_field is the target column to unnest,
          usually 'req_body' or 'resp'.
          '''
          # Get topic_name
          df.topics = px.pluck(df[body_field], 'topics')
          df = json_unnest_first5(df, 'topic', 'topics')
          df = df[df.topic != '']
          df.topic_name = px.pluck(df.topic, 'name')

          # Get partition_idx
          df.partitions = px.pluck(df.topic, 'partitions')
          df = json_unnest_first5(df, 'partition', 'partitions')
          df = df[df.partition != '']
          df.partition_idx = px.pluck(df.partition, 'index')

          # Get message_size
          df.message_set = px.pluck(df.partition, 'message_set')
          df.message_size = px.pluck(df.message_set, 'size')
          df.message_size = px.atoi(df.message_size, 0)
          return df


      def json_unnest_first5(df, dest_col, src_col):
          '''Unnest the first 5 values in a JSON array in the src_col, and put it in the
          dest_col.
          '''
          df0 = json_array_index(df, dest_col, src_col, 0)
          df1 = json_array_index(df, dest_col, src_col, 1)
          df2 = json_array_index(df, dest_col, src_col, 2)
          df3 = json_array_index(df, dest_col, src_col, 3)
          df4 = json_array_index(df, dest_col, src_col, 4)
          df = df0.append(df1).append(df2).append(df3).append(df4)
          return df


      def json_array_index(df, dest_col, src_col, idx):
          df[dest_col] = px.pluck_array(df[src_col], idx)
          return df


      def select_columns(df):
          return df[[
              'time_', 'upid', 'req_cmd', 'client_id', 'latency',
              'source_pod', 'destination_pod', 'source_service', 'destination_service',
              'source_namespace', 'destination_namespace',
              'topic_name', 'partition_idx', 'message_size', 'error_code',
          ]]


      def get_produce_records(df):
          '''
          Get all the produce records and filter by a specified topic. If topic is empty, all
          produce records are retained.
          '''
          # Produce requests have command 0.
          producer_df = df[df.req_cmd == 0]

          producer_df = unnest_topics_and_partitions(producer_df, 'req_body')
          producer_df.req_partition_idx = df.partition_idx
          # Error code is always in the response.
          producer_df = unnest_topics_and_partitions(producer_df, 'resp')

          producer_df.error_code = px.pluck(producer_df.partition, 'error_code')
          producer_df = producer_df[producer_df.partition_idx == producer_df.req_partition_idx]
          return select_columns(producer_df)


      def get_fetch_records(df):
          '''
          Get all the fetch records and filter by a specified topic. If topic is empty, all
          fetch records are retained.
          '''
          # Fetch requests have command 1.
          consumer_df = df[df.req_cmd == 1]

          consumer_df = unnest_topics_and_partitions(consumer_df, 'resp')
          consumer_df.error_code = px.pluck(consumer_df.partition, 'error_code')
          return select_columns(consumer_df)


      def get_remaining_records(df):
          '''
          Get all the fetch records and filter by a specified topic. If topic is empty, all
          fetch records are retained.
          '''
          # Exclude Produce (cmd 0) and Fetch (cmd 1) commands.
          df = df[df.req_cmd > 1]
          df.topic_name = ''
          df.partition_idx = ''
          df.message_size = 0
          df.error_code = '0'
          return select_columns(df)

      def remove_ns_prefix(column):
          return px.replace('[a-z0-9\-]*/', column, '')

      def add_source_dest_columns(df):
          df.pod = df.ctx['pod']
          df.namespace = df.ctx['namespace']

          # If remote_addr is a pod, get its name. If not, use IP address.
          df.ra_pod = px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr))
          df.is_ra_pod = df.ra_pod != ''
          df.ra_name = px.select(df.is_ra_pod, df.ra_pod, df.remote_addr)

          df.is_server_tracing = df.trace_role == 2
          df.is_source_pod_type = px.select(df.is_server_tracing, df.is_ra_pod, True)
          df.is_dest_pod_type = px.select(df.is_server_tracing, True, df.is_ra_pod)

          # Set client and server based on trace_role.
          df.source_pod = px.select(df.is_server_tracing, df.ra_name, df.pod)
          df.destination_pod = px.select(df.is_server_tracing, df.pod, df.ra_name)

          df = df.drop(['ra_pod', 'is_ra_pod', 'ra_name', 'is_server_tracing'])
          df.source_service = px.pod_name_to_service_name(df.source_pod)
          df.destination_service = px.pod_name_to_service_name(df.destination_pod)
          df.destination_namespace = px.pod_name_to_namespace(df.destination_pod)
          df.source_namespace = px.pod_name_to_namespace(df.source_pod)

          df.source_service = remove_ns_prefix(df.source_service)
          df.destination_service = remove_ns_prefix(df.destination_service)
          df.source_pod = remove_ns_prefix(df.source_pod)
          df.destination_pod = remove_ns_prefix(df.destination_pod)

          # If the destination service is missing then try the nslookup
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              px.nslookup(df.remote_addr),
          )
          # If the destination service is still missing then set the remote_addr
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              df.remote_addr,
          )
          return df

      df = px.DataFrame(table='kafka_events.beta', start_time=px.plugin.start_time, end_time=px.plugin.end_time)
      df.namespace = df.ctx['namespace']

      df = add_source_dest_columns(df)
      producer_df = get_produce_records(df)
      consumer_df = get_fetch_records(df)
      remaining_df = get_remaining_records(df)
      df = producer_df.append([consumer_df, remaining_df])

      # Convert latency from ns units to ms units.
      df.latency = df.latency / (1000.0 * 1000.0)

      # Get throughput by adding size of message_sets. Note that this is the total size of the
      # message batches, not the total number of bytes sent or received.
      df.has_error = df.error_code != 'kNone' and df.error_code != '0'
      df = df.groupby([
          'source_namespace',
          'destination_namespace',
          'source_service',
          'destination_service',
          'source_pod',
          'destination_pod',
          'has_error',
          'partition_idx',
          'client_id',
          'topic_name',
          'req_cmd',
      ]).agg(
          record_bytes_total=('message_size', px.sum),
          latency_count=('message_size', px.count),
          latency_sum=('latency', px.sum),
          latency_max=('latency', px.max),
          latency_min=('latency', px.min),
          time_=('time_', px.max),
      )

      df.record_bytes_total = px.Bytes(df.record_bytes_total)
      df.pixie = 'pixie'
      df.cluster_id = px.vizier_id()
      df.cluster_name = px.vizier_name()
      df.req_cmd = px.kafka_api_key_name(df.req_cmd)

      px.export(
          df,
          px.otel.Data(
              resource={
                  'service.name': df.source_service,
                  'service.instance.id': df.source_pod,
                  'k8s.pod.name': df.source_pod,
                  'k8s.namespace.name': df.source_namespace,
                  'k8s.cluster.name': df.cluster_name,
                  'px.cluster.id': df.cluster_id,
                  'instrumentation.provider': df.pixie,
                  'kafka.service.name': df.destination_service,
                  'kafka.broker.pod': df.destination_pod,
                  'kafka.namespace.name': df.destination_namespace,
                  'kafka.client_id': df.client_id,
                  'kafka.has_error': df.has_error,
                  'kafka.partition_idx': df.partition_idx,
                  'kafka.req_cmd': df.req_cmd,
                  'kafka.topic_name': df.topic_name,
              },
              data=[
                  px.otel.metric.Summary(
                      name='kafka.latency',
                      description='Summary of latency for Kafka requests',
                      count=df.latency_count,
                      sum=df.latency_sum,
                      unit='ms',
                      quantile_values={
                          0.0: df.latency_min,
                          1.0: df.latency_max,
                      },
                  ),
                  px.otel.metric.Gauge(
                      name='kafka.bytes',
                      description='The total number of bytes sent or received through Kafka requests',
                      value=df.record_bytes_total,
                  ),
              ],
          ),
      )
  - name: "Kafka Spans"
    description: "This script samples Kafka Spans and sends them to New Relic's OTel endpoint."
    defaultDisabled: true
    defaultFrequencyS: 10
    script: |
      import px

      def unnest_topics_and_partitions(df, body_field: str):
          '''
          Unnest the topics and partitions from a data frame. body_field is the target column to unnest,
          usually 'req_body' or 'resp'.
          '''
          # Get topic_name
          df.topics = px.pluck(df[body_field], 'topics')
          df = json_unnest_first5(df, 'topic', 'topics')
          df = df[df.topic != '']
          df.topic_name = px.pluck(df.topic, 'name')

          # Get partition_idx
          df.partitions = px.pluck(df.topic, 'partitions')
          df = json_unnest_first5(df, 'partition', 'partitions')
          df = df[df.partition != '']
          df.partition_idx = px.pluck(df.partition, 'index')

          # Get message_size
          df.message_set = px.pluck(df.partition, 'message_set')
          df.message_size = px.pluck(df.message_set, 'size')
          df.message_size = px.atoi(df.message_size, 0)
          return df


      def json_unnest_first5(df, dest_col, src_col):
          '''Unnest the first 5 values in a JSON array in the src_col, and put it in the
          dest_col.
          '''
          df0 = json_array_index(df, dest_col, src_col, 0)
          df1 = json_array_index(df, dest_col, src_col, 1)
          df2 = json_array_index(df, dest_col, src_col, 2)
          df3 = json_array_index(df, dest_col, src_col, 3)
          df4 = json_array_index(df, dest_col, src_col, 4)
          df = df0.append(df1).append(df2).append(df3).append(df4)
          return df


      def json_array_index(df, dest_col, src_col, idx):
          df[dest_col] = px.pluck_array(df[src_col], idx)
          return df


      def select_columns(df):
          return df[[
              'time_', 'upid', 'req_cmd', 'client_id', 'latency',
              'source_pod', 'destination_pod', 'source_service', 'destination_service',
              'source_namespace', 'destination_namespace', 'req_body', 'resp',
              'topic_name', 'partition_idx', 'partition',
              'message_size', 'error_code',
          ]]


      def get_produce_records(df):
          '''
          Get all the produce records and filter by a specified topic. If topic is empty, all
          produce records are retained.
          '''
          # Produce requests have command 0.
          producer_df = df[df.req_cmd == 0]

          producer_df = unnest_topics_and_partitions(producer_df, 'req_body')
          producer_df.req_partition_idx = df.partition_idx
          # Error code is always in the response.
          producer_df = unnest_topics_and_partitions(producer_df, 'resp')

          producer_df.error_code = px.pluck(producer_df.partition, 'error_code')
          producer_df = producer_df[producer_df.partition_idx == producer_df.req_partition_idx]
          return select_columns(producer_df)


      def get_fetch_records(df):
          '''
          Get all the fetch records and filter by a specified topic. If topic is empty, all
          fetch records are retained.
          '''
          # Fetch requests have command 1.
          consumer_df = df[df.req_cmd == 1]

          consumer_df = unnest_topics_and_partitions(consumer_df, 'resp')
          consumer_df.error_code = px.pluck(consumer_df.partition, 'error_code')
          return select_columns(consumer_df)


      def get_remaining_records(df):
          '''
          Get all the fetch records and filter by a specified topic. If topic is empty, all
          fetch records are retained.
          '''
          # Exclude Produce (cmd 0) and Fetch (cmd 1) commands.
          df = df[df.req_cmd > 1]
          df.topic_name = ''
          df.partition_idx = ''
          df.partition = ''
          df.message_size = 0
          df.error_code = '0'
          return select_columns(df)

      def remove_ns_prefix(column):
          return px.replace('[a-z0-9\-]*/', column, '')

      def add_source_dest_columns(df):
          df.pod = df.ctx['pod']
          df.namespace = df.ctx['namespace']

          # If remote_addr is a pod, get its name. If not, use IP address.
          df.ra_pod = px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr))
          df.is_ra_pod = df.ra_pod != ''
          df.ra_name = px.select(df.is_ra_pod, df.ra_pod, df.remote_addr)

          df.is_server_tracing = df.trace_role == 2
          df.is_source_pod_type = px.select(df.is_server_tracing, df.is_ra_pod, True)
          df.is_dest_pod_type = px.select(df.is_server_tracing, True, df.is_ra_pod)

          # Set client and server based on trace_role.
          df.source_pod = px.select(df.is_server_tracing, df.ra_name, df.pod)
          df.destination_pod = px.select(df.is_server_tracing, df.pod, df.ra_name)

          df = df.drop(['ra_pod', 'is_ra_pod', 'ra_name', 'is_server_tracing'])
          df.source_service = px.pod_name_to_service_name(df.source_pod)
          df.destination_service = px.pod_name_to_service_name(df.destination_pod)
          df.destination_namespace = px.pod_name_to_namespace(df.destination_pod)
          df.source_namespace = px.pod_name_to_namespace(df.source_pod)

          df.source_service = remove_ns_prefix(df.source_service)
          df.destination_service = remove_ns_prefix(df.destination_service)
          df.source_pod = remove_ns_prefix(df.source_pod)
          df.destination_pod = remove_ns_prefix(df.destination_pod)

          # If the destination service is missing then try the nslookup
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              px.nslookup(df.remote_addr),
          )
          # If the destination service is still missing then set the remote_addr
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              df.remote_addr,
          )
          return df

      df = px.DataFrame(table='kafka_events.beta', start_time=px.plugin.start_time, end_time=px.plugin.end_time)
      df.namespace = df.ctx['namespace']

      df = add_source_dest_columns(df)
      producer_df = get_produce_records(df)
      consumer_df = get_fetch_records(df)
      remaining_df = get_remaining_records(df)
      df = producer_df.append([consumer_df, remaining_df])

      # Convert latency from ns units to ms units.
      df.start_time = df.time_ - df.latency
      df.latency = df.latency / (1000.0 * 1000.0)

      # Get throughput by adding size of message_sets. Note that this is the total size of the
      # message batches, not the total number of bytes sent or received.
      df.has_error = df.error_code != 'kNone' and df.error_code != '0'
      df.req_cmd = px.kafka_api_key_name(df.req_cmd)
      df.pixie = "pixie"
      df.cluster_id = px.vizier_id()
      df.cluster_name = px.vizier_name()
      df.span_name = df.req_cmd + '/' + df.topic_name

      # Restrict number of results.
      df = df.head(1500)
      px.export(
          df,
          px.otel.Data(
              resource={
                  'service.name': df.source_service,
                  'service.instance.id': df.source_pod,
                  'k8s.pod.name': df.source_pod,
                  'k8s.namespace.name': df.source_namespace,
                  'k8s.cluster.name': df.cluster_name,
                  'px.cluster.id': df.cluster_id,
                  'instrumentation.provider': df.pixie,
                  'kafka.service.name': df.destination_service,
                  'kafka.broker.pod': df.destination_pod,
                  'kafka.namespace.name': df.destination_namespace,
              },
              data=[
                  px.otel.trace.Span(
                      name=df.span_name,
                      start_time=df.start_time,
                      end_time=df.time_,
                      kind=px.otel.trace.SPAN_KIND_CLIENT,
                      attributes={
                          "kafka.client_id": df.client_id,
                          "kafka.has_error": df.has_error,
                          "kafka.message_size": df.message_size,
                          "kafka.partition_idx": df.partition_idx,
                          "kafka.partition": df.partition,
                          "kafka.req_body": df.req_body,
                          "kafka.req_cmd": df.req_cmd,
                          "kafka.resp": df.resp,
                          "kafka.topic": df.topic_name,
                      },
                  )
              ],
          ),
      )
  - name: Redis Spans
    description: This script generates OpenTelemetry spans for Redis commands.
    defaultDisabled: true
    defaultFrequencyS: 10
    script: |
      #px:set max_output_rows_per_table=500
      import px

      def remove_ns_prefix(column):
          return px.replace('[a-z0-9\-]*/', column, '')

      def add_source_dest_columns(df):
          df.pod = df.ctx['pod']
          df.namespace = df.ctx['namespace']

          # If remote_addr is a pod, get its name. If not, use IP address.
          df.ra_pod = px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr))
          df.is_ra_pod = df.ra_pod != ''
          df.ra_name = px.select(df.is_ra_pod, df.ra_pod, df.remote_addr)

          df.is_server_tracing = df.trace_role == 2
          df.is_source_pod_type = px.select(df.is_server_tracing, df.is_ra_pod, True)
          df.is_dest_pod_type = px.select(df.is_server_tracing, True, df.is_ra_pod)

          # Set client and server based on trace_role.
          df.source_pod = px.select(df.is_server_tracing, df.ra_name, df.pod)
          df.destination_pod = px.select(df.is_server_tracing, df.pod, df.ra_name)

          df = df.drop(['ra_pod', 'is_ra_pod', 'ra_name', 'is_server_tracing'])
          df.source_service = px.pod_name_to_service_name(df.source_pod)
          df.destination_service = px.pod_name_to_service_name(df.destination_pod)
          df.destination_namespace = px.pod_name_to_namespace(df.destination_pod)
          df.source_namespace = px.pod_name_to_namespace(df.source_pod)

          df.source_service = remove_ns_prefix(df.source_service)
          df.destination_service = remove_ns_prefix(df.destination_service)
          df.source_pod = remove_ns_prefix(df.source_pod)
          df.destination_pod = remove_ns_prefix(df.destination_pod)

          # If the destination service is missing then try the nslookup
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              px.nslookup(df.remote_addr),
          )
          # If the destination service is still missing then set the remote_addr
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              df.remote_addr,
          )
          return df


      df = px.DataFrame('redis_events', start_time=px.plugin.start_time, end_time=px.plugin.end_time)
      df = add_source_dest_columns(df)

      df.start_time = df.time_ - df.latency
      df.latency = df.latency / (1000 * 1000)
      df.req_bytes = px.length(df.req_args)
      df.resp_bytes = px.length(df.resp)
      df.pixie = 'pixie'
      df.cluster_id = px.vizier_id()
      df.cluster_name = px.vizier_name()

      px.export(df, px.otel.Data(
        resource={
          'service.name': df.source_service,
          'service.instance.id': df.source_pod,
          'k8s.namespace.name': df.source_namespace,
          'redis.service.name': df.destination_service,
          'redis.pod.name': df.destination_pod,
          'redis.namespace.name': df.destination_namespace,
          'redis.req_cmd': df.req_cmd,
          'k8s.cluster.name': df.cluster_name,
          'px.cluster.id': df.cluster_id,
          'instrumentation.provider': df.pixie,
        },
        data=[
          px.otel.trace.Span(
            name=df.req_cmd,
            start_time=df.start_time,
            end_time=df.time_,
            kind=px.otel.trace.SPAN_KIND_CLIENT,
            attributes={
              'redis.req_bytes': df.req_bytes,
              'redis.resp_bytes': df.resp_bytes,
              'redis.resp_latency': df.latency,
              'redis.req_args': df.req_args,
              'redis.resp': df.resp,
            },
          )
        ]
      ))
  - name: Redis Metrics
    description: This script exports Redis metrics to New Relic.
    defaultDisabled: true
    defaultFrequencyS: 10
    script: |
      #px:set max_output_rows_per_table=10000
      import px

      def remove_ns_prefix(column):
          return px.replace('[a-z0-9\-]*/', column, '')

      def add_source_dest_columns(df):
          df.pod = df.ctx['pod']
          df.namespace = df.ctx['namespace']

          # If remote_addr is a pod, get its name. If not, use IP address.
          df.ra_pod = px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr))
          df.is_ra_pod = df.ra_pod != ''
          df.ra_name = px.select(df.is_ra_pod, df.ra_pod, df.remote_addr)

          df.is_server_tracing = df.trace_role == 2
          df.is_source_pod_type = px.select(df.is_server_tracing, df.is_ra_pod, True)
          df.is_dest_pod_type = px.select(df.is_server_tracing, True, df.is_ra_pod)

          # Set client and server based on trace_role.
          df.source_pod = px.select(df.is_server_tracing, df.ra_name, df.pod)
          df.destination_pod = px.select(df.is_server_tracing, df.pod, df.ra_name)

          df = df.drop(['ra_pod', 'is_ra_pod', 'ra_name', 'is_server_tracing'])
          df.source_service = px.pod_name_to_service_name(df.source_pod)
          df.destination_service = px.pod_name_to_service_name(df.destination_pod)
          df.destination_namespace = px.pod_name_to_namespace(df.destination_pod)
          df.source_namespace = px.pod_name_to_namespace(df.source_pod)

          df.source_service = remove_ns_prefix(df.source_service)
          df.destination_service = remove_ns_prefix(df.destination_service)
          df.source_pod = remove_ns_prefix(df.source_pod)
          df.destination_pod = remove_ns_prefix(df.destination_pod)

          # If the destination service is missing then try the nslookup
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              px.nslookup(df.remote_addr),
          )
          # If the destination service is still missing then set the remote_addr
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              df.remote_addr,
          )
          return df

      df = px.DataFrame('redis_events', start_time=px.plugin.start_time, end_time=px.plugin.end_time)
      df = add_source_dest_columns(df)

      df.latency = df.latency / (1000 * 1000)
      df.req_bytes = px.length(df.req_args)
      df.resp_bytes = px.length(df.resp)
      df = df.groupby(['req_cmd', 'source_pod', 'source_service', 'source_namespace', 'destination_pod', 'destination_service', 'destination_namespace']).agg(
          latency_count=('latency', px.count),
          latency_min=('latency', px.min),
          latency_max=('latency', px.max),
          latency_sum=('latency', px.sum),
          time_=('time_', px.max),
          req_bytes=('req_bytes', px.sum),
          resp_bytes=('resp_bytes', px.sum),
      )

      df.pixie = 'pixie'
      df.cluster_id = px.vizier_id()
      df.cluster_name = px.vizier_name()

      px.export(df, px.otel.Data(
        resource={
          'service.name': df.source_service,
          'service.instance.id': df.source_pod,
          'k8s.namespace.name': df.source_namespace,
          'redis.service.name': df.destination_service,
          'redis.pod.name': df.destination_pod,
          'redis.namespace.name': df.destination_namespace,
          'redis.req_cmd': df.req_cmd,
          'k8s.cluster.name': df.cluster_name,
          'px.cluster.id': df.cluster_id,
          'instrumentation.provider': df.pixie,
        },
        data=[
          px.otel.metric.Summary(
              name='redis.latency',
              count=df.latency_count,
              sum=df.latency_sum,
              unit='ms',
              quantile_values={
                  0.0: df.latency_min,
                  1.0: df.latency_max,
              },
          ),
          px.otel.metric.Gauge(
            name='redis.req_bytes',
            description='',
            value=df.req_bytes,
          ),
          px.otel.metric.Gauge(
            name='redis.resp_bytes',
            description='',
            value=df.resp_bytes,
          )
        ]
      ))
  - name: "DNS Metrics"
    description: "This script calculates DNS request metrics"
    defaultDisabled: true
    defaultFrequencyS: 10
    script: |
      #px:set max_output_rows_per_table=10000
      import px

      df = px.DataFrame('dns_events', start_time=px.plugin.start_time, end_time=px.plugin.end_time)
      df = df[df.trace_role == 1]
      df = df.drop(['trace_role'])

      # Add context.
      df.pod = df.ctx['pod']
      df.service = df.ctx['service']
      df.namespace = df.ctx['namespace']
      df.node = df.ctx['node']
      df.container = df.ctx['container']
      df = df.drop(['upid'])
      # Extract some fields into their own columns for convenience.
      df.queries = px.pluck(df.req_body, 'queries')
      df.answers = px.pluck(df.resp_body, 'answers')
      df.rcode = px.pluck_int64(df.resp_header, 'rcode')
      df.resolved = px.contains(df.answers, 'name')
      df.query = px.replace('.*"name":"(.*?)".*', df.queries, '\\1')
      df.query_type = px.replace('.*"type":"(.*?)".*', df.queries, '\\1')
      # Convert DNS IP to string service name
      df.dns_server = px.service_id_to_service_name(px.ip_to_service_id(df.remote_addr))
      # If the dns service is missing then try by pod
      df.dns_server = px.select(
          df.dns_server != '',
          df.dns_server,
          px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr)),
      )

      # If the dns service is missing then try the nslookup
      df.dns_server = px.select(
          df.dns_server != '',
          df.dns_server,
          px.nslookup(df.remote_addr),
      )
      # If the dns service is still missing then set the remote_addr
      df.dns_server = px.select(
          df.dns_server != '',
          df.dns_server,
          df.remote_addr,
      )
      df.namespace = px.pod_name_to_namespace(df.pod)
      def remove_ns_prefix(column):
          return px.replace('[a-z0-9\-]*/', column, '')
      df.pod = remove_ns_prefix(df.pod)
      df.service = remove_ns_prefix(df.service)
      # Before aggregating, output individual requests to drawer.
      # Convert latency from ns units to ms units.
      df.latency = df.latency / (1000 * 1000)
      # Aggregate by each pod making a query to a particular DNS.
      df = df.groupby(['container', 'pod', 'service', 'dns_server', 'query', 'namespace', 'node', 'rcode', 'resolved', 'query_type']).agg(
          time_=('time_', px.max),
          latency_max=('latency', px.max),
          latency_min=('latency', px.min),
          latency_count=('latency', px.count),
          latency_sum=('latency', px.sum),
      )
      df.pixie = 'pixie'
      df.cluster_id = px.vizier_id()
      df.cluster_name = px.vizier_name()
      df.dns_server_name = remove_ns_prefix(df.dns_server)
      df.dns_server_namespace = px.pod_name_to_namespace(df.dns_server)
      # Choose the current namespace if the server name is localhost
      df.dns_server_namespace = px.select(df.dns_server == 'localhost', df.namespace, df.dns_server_namespace)
      df.dns_cluster_id = px.select(df.dns_server_namespace == '', '', px.vizier_id())
      px.export(df, px.otel.Data(
        resource={
          'service.name': df.service,
          'service.instance.id': df.pod,
          'k8s.pod.name': df.pod,
          'k8s.namespace.name': df.namespace,
          'k8s.container.name': df.container,
          'k8s.cluster.name': df.cluster_name,
          'px.cluster.id': df.cluster_id,
          'instrumentation.provider': df.pixie,
          'dns.server.name': df.dns_server_name,
          'dns.server.namespace': df.dns_server_namespace,
          'dns.server.cluster_id': df.dns_cluster_id,
          'dns.query': df.query,
          'dns.rcode': df.rcode,
          'dns.resolved': df.resolved,
          'dns.query_type': df.query_type,
        },
        data=[
          px.otel.metric.Summary(
              name='dns.latency',
              count=df.latency_count,
              sum=df.latency_sum,
              unit='ms',
              quantile_values={
                  0.0: df.latency_min,
                  1.0: df.latency_max,
              },
          ),
        ]
      ))
  - name: "DNS Spans"
    description: "Exports a sample of DNS Spans from Pixie data"
    defaultDisabled: true
    defaultFrequencyS: 10
    script: |
      #px:set max_output_rows_per_table=500
      import px

      df = px.DataFrame('dns_events', start_time=px.plugin.start_time, end_time=px.plugin.end_time)
      df = df[df.trace_role == 1]
      df = df.drop(['trace_role'])

      # Add context.
      df.pod = df.ctx['pod']
      df.service = df.ctx['service']
      df.namespace = df.ctx['namespace']
      df.node = df.ctx['node']
      df.container = df.ctx['container']
      df = df.drop(['upid'])


      # Extract some fields into their own columns for convenience.
      df.queries = px.pluck(df.req_body, 'queries')
      df.answers = px.pluck(df.resp_body, 'answers')
      df.rcode = px.pluck_int64(df.resp_header, 'rcode')
      df.resolved = px.contains(df.answers, 'name')

      df.query = px.replace('.*"name":"(.*?)".*', df.queries, '\\1')
      df.query_type = px.replace('.*"type":"(.*?)".*', df.queries, '\\1')

      # Convert DNS IP to string service name
      df.dns_server = px.service_id_to_service_name(px.ip_to_service_id(df.remote_addr))
      # If the dns service is missing then try by pod
      df.dns_server = px.select(
          df.dns_server != '',
          df.dns_server,
          px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr)),
      )
      # If the dns service is missing then try the nslookup
      df.dns_server = px.select(
          df.dns_server != '',
          df.dns_server,
          px.nslookup(df.remote_addr),
      )
      # If the dns service is still missing then set the remote_addr
      df.dns_server = px.select(
          df.dns_server != '',
          df.dns_server,
          df.remote_addr,
      )
      df.namespace = px.pod_name_to_namespace(df.pod)

      def remove_ns_prefix(column):
          return px.replace('[a-z0-9\-]*/', column, '')

      df.pod = remove_ns_prefix(df.pod)
      df.service = remove_ns_prefix(df.service)

      df.start_time = df.time_ - df.latency
      # Before aggregating, output individual requests to drawer.
      # Convert latency from ns units to ms units.
      df.latency = df.latency / (1000 * 1000)

      df.pixie = 'pixie'
      df.cluster_id = px.vizier_id()
      df.cluster_name = px.vizier_name()
      df.dns_server_name = remove_ns_prefix(df.dns_server)
      df.dns_server_namespace = px.pod_name_to_namespace(df.dns_server)
      # Choose the current namespace if the server name is localhost
      df.dns_server_namespace = px.select(df.dns_server == 'localhost', df.namespace, df.dns_server_namespace)
      df.dns_cluster_id = px.select(df.dns_server_namespace == '', '', px.vizier_id())

      px.export(df, px.otel.Data(
        resource={
          'service.name': df.service,
          'service.instance.id': df.pod,
          'k8s.pod.name': df.pod,
          'k8s.namespace.name': df.namespace,
          'k8s.container.name': df.container,
          'k8s.cluster.name': df.cluster_name,
          'px.cluster.id': df.cluster_id,
          'instrumentation.provider': df.pixie,
        },
        data=[
          px.otel.trace.Span(
            name='dns',
            start_time=df.start_time,
            end_time=df.time_,
            kind=px.otel.trace.SPAN_KIND_CLIENT,
            attributes={
                'dns.latency': df.latency,
                'dns.req_body': df.req_body,
                'dns.resp_body': df.resp_body,
                'dns.server.name': df.dns_server_name,
                'dns.server.namespace': df.dns_server_namespace,
                'dns.server.cluster_id': df.dns_cluster_id,
                'dns.query': df.query,
                'dns.rcode': df.rcode,
                'dns.resolved': df.resolved,
                'dns.query_type': df.query_type,
            },
          )
        ]
      ))
  - name: Cassandra Spans
    description: This script generates OpenTelemetry spans for Cassandra span events.
    defaultDisabled: true
    defaultFrequencyS: 10
    script: |
      #px:set max_output_rows_per_table=500
      import px

      def cql_opname(df, input_col_name, output_col_name):
          df[output_col_name] = 'Unknown'
          df[output_col_name] = px.select(df[input_col_name]==1, 'Startup', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==5, 'Options', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==7, 'Query', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==9, 'Prepare', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==10, 'Execute', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==11, 'Register', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==13, 'Batch', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==15, 'AuthResponse', df[output_col_name])
          return df

      def remove_ns_prefix(column):
          return px.replace('[a-z0-9\-]*/', column, '')

      def add_source_dest_columns(df):
          df.pod = df.ctx['pod']
          df.namespace = df.ctx['namespace']

          # If remote_addr is a pod, get its name. If not, use IP address.
          df.ra_pod = px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr))
          df.is_ra_pod = df.ra_pod != ''
          df.ra_name = px.select(df.is_ra_pod, df.ra_pod, df.remote_addr)

          df.is_server_tracing = df.trace_role == 2
          df.is_source_pod_type = px.select(df.is_server_tracing, df.is_ra_pod, True)
          df.is_dest_pod_type = px.select(df.is_server_tracing, True, df.is_ra_pod)

          # Set client and server based on trace_role.
          df.source_pod = px.select(df.is_server_tracing, df.ra_name, df.pod)
          df.destination_pod = px.select(df.is_server_tracing, df.pod, df.ra_name)

          df = df.drop(['ra_pod', 'is_ra_pod', 'ra_name', 'is_server_tracing'])
          df.source_service = px.pod_name_to_service_name(df.source_pod)
          df.destination_service = px.pod_name_to_service_name(df.destination_pod)
          df.destination_namespace = px.pod_name_to_namespace(df.destination_pod)
          df.source_namespace = px.pod_name_to_namespace(df.source_pod)

          df.source_service = remove_ns_prefix(df.source_service)
          df.destination_service = remove_ns_prefix(df.destination_service)
          df.source_pod = remove_ns_prefix(df.source_pod)
          df.destination_pod = remove_ns_prefix(df.destination_pod)

          # If the destination service is missing then try the nslookup
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              px.nslookup(df.remote_addr),
          )
          # If the destination service is still missing then set the remote_addr
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              df.remote_addr,
          )
          return df

      df = px.DataFrame('cql_events', start_time=px.plugin.start_time, end_time=px.plugin.end_time)
      df = add_source_dest_columns(df)

      df.start_time = df.time_ - df.latency
      df.latency = df.latency / (1000 * 1000)
      df.req_bytes = px.length(df.req_body)
      df.resp_bytes = px.length(df.resp_body)
      df = cql_opname(df, 'req_op', 'req_cmd')

      df.pixie = 'pixie'
      df.cluster_id = px.vizier_id()
      df.cluster_name = px.vizier_name()
      df.db_system = 'cassandra'

      px.export(
        df, px.otel.Data(
          resource={
            'service.name': df.source_service,
            'service.instance.id': df.source_pod,
            'k8s.namespace.name': df.source_namespace,
            'cassandra.service.name': df.destination_service,
            'cassandra.pod.name': df.destination_pod,
            'cassandra.namespace.name': df.destination_namespace,
            'cassandra.req_cmd': df.req_cmd,
            'cassandra.req_body': df.req_body,
            'cassandra.req_bytes': df.req_bytes,
            'cassandra.resp_op': df.resp_op,
            'cassandra.resp_body': df.resp_op,
            'cassandra.resp_bytes': df.resp_bytes,
            'cassandra.resp_latency': df.latency,
            'k8s.cluster.name': df.cluster_name,
            'px.cluster.id': df.cluster_id,
            'instrumentation.provider': df.pixie,
            'db.system': df.db_system,
          },
          data=[
            px.otel.trace.Span(
              name=df.req_cmd,
              start_time=df.start_time,
              end_time=df.time_,
              kind=px.otel.trace.SPAN_KIND_CLIENT,
            ),
          ],
        ),
      )
  - name: Cassandra Metrics
    description: This script exports Cassandra metrics to New Relic.
    defaultDisabled: true
    defaultFrequencyS: 10
    script: |
      #px:set max_output_rows_per_table=10000
      import px

      def cql_opname(df, input_col_name, output_col_name):
          df[output_col_name] = 'Unknown'
          df[output_col_name] = px.select(df[input_col_name]==1, 'Startup', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==5, 'Options', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==7, 'Query', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==9, 'Prepare', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==10, 'Execute', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==11, 'Register', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==13, 'Batch', df[output_col_name])
          df[output_col_name] = px.select(df[input_col_name]==15, 'AuthResponse', df[output_col_name])
          return df

      def remove_ns_prefix(column):
          return px.replace('[a-z0-9\-]*/', column, '')

      def add_source_dest_columns(df):
          df.pod = df.ctx['pod']
          df.namespace = df.ctx['namespace']

          # If remote_addr is a pod, get its name. If not, use IP address.
          df.ra_pod = px.pod_id_to_pod_name(px.ip_to_pod_id(df.remote_addr))
          df.is_ra_pod = df.ra_pod != ''
          df.ra_name = px.select(df.is_ra_pod, df.ra_pod, df.remote_addr)

          df.is_server_tracing = df.trace_role == 2
          df.is_source_pod_type = px.select(df.is_server_tracing, df.is_ra_pod, True)
          df.is_dest_pod_type = px.select(df.is_server_tracing, True, df.is_ra_pod)

          # Set client and server based on trace_role.
          df.source_pod = px.select(df.is_server_tracing, df.ra_name, df.pod)
          df.destination_pod = px.select(df.is_server_tracing, df.pod, df.ra_name)

          df = df.drop(['ra_pod', 'is_ra_pod', 'ra_name', 'is_server_tracing'])
          df.source_service = px.pod_name_to_service_name(df.source_pod)
          df.destination_service = px.pod_name_to_service_name(df.destination_pod)
          df.destination_namespace = px.pod_name_to_namespace(df.destination_pod)
          df.source_namespace = px.pod_name_to_namespace(df.source_pod)

          df.source_service = remove_ns_prefix(df.source_service)
          df.destination_service = remove_ns_prefix(df.destination_service)
          df.source_pod = remove_ns_prefix(df.source_pod)
          df.destination_pod = remove_ns_prefix(df.destination_pod)

          # If the destination service is missing then try the nslookup
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              px.nslookup(df.remote_addr),
          )
          # If the destination service is still missing then set the remote_addr
          df.destination_service = px.select(
              df.destination_service != '',
              df.destination_service,
              df.remote_addr,
          )
          return df

      df = px.DataFrame('cql_events', start_time=px.plugin.start_time, end_time=px.plugin.end_time)
      df = add_source_dest_columns(df)

      df.start_time = df.time_ - df.latency
      df.latency = df.latency / (1000 * 1000)
      df.req_bytes = px.length(df.req_body)
      df.resp_bytes = px.length(df.resp_body)
      df = df.groupby(['source_pod', 'source_service', 'source_namespace', 'destination_pod', 'destination_service',
                        'destination_namespace', 'req_op']).agg(
          latency_count=('latency', px.count),
          latency_min=('latency', px.min),
          latency_max=('latency', px.max),
          latency_sum=('latency', px.sum),
          time_=('time_', px.max),
          req_bytes=('req_bytes', px.sum),
          resp_bytes=('resp_bytes', px.sum),
      )
      df = cql_opname(df, 'req_op', 'req_cmd')

      df.pixie = 'pixie'
      df.cluster_id = px.vizier_id()
      df.cluster_name = px.vizier_name()
      df.db_system = 'cassandra'

      px.export(
        df, px.otel.Data(
          resource={
            'service.name': df.source_service,
            'service.instance.id': df.source_pod,
            'k8s.namespace.name': df.source_namespace,
            'cassandra.service.name': df.destination_service,
            'cassandra.pod.name': df.destination_pod,
            'cassandra.namespace.name': df.destination_namespace,
            'cassandra.req_cmd': df.req_cmd,
            'k8s.cluster.name': df.cluster_name,
            'px.cluster.id': df.cluster_id,
            'instrumentation.provider': df.pixie,
            'db.system': df.db_system,
          },
          data=[
            px.otel.metric.Summary(
              name='cassandra.latency',
              count=df.latency_count,
              sum=df.latency_sum,
              unit='ms',
              quantile_values={
                0.0: df.latency_min,
                1.0: df.latency_max,
              },
            ),
            px.otel.metric.Gauge(
              name='cassandra.req_bytes',
              description='',
              value=df.req_bytes,
            ),
            px.otel.metric.Gauge(
              name='cassandra.resp_bytes',
              description='',
              value=df.resp_bytes,
            ),
          ],
        ),
      )
